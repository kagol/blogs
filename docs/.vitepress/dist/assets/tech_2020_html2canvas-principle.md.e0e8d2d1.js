import{_ as a,B as n,o as l,c as o,G as p,Q as t}from"./chunks/framework.1fee3549.js";const E=JSON.parse('{"title":"html2canvas 实现浏览器截图的原理","description":"","frontmatter":{},"headers":[],"relativePath":"tech/2020/html2canvas-principle.md","filePath":"tech/2020/html2canvas-principle.md"}'),e={name:"tech/2020/html2canvas-principle.md"},r=t(`<h1 id="html2canvas-实现浏览器截图的原理" tabindex="-1">html2canvas 实现浏览器截图的原理 <a class="header-anchor" href="#html2canvas-实现浏览器截图的原理" aria-label="Permalink to &quot;html2canvas 实现浏览器截图的原理&quot;">​</a></h1><p><img src="https://user-images.githubusercontent.com/9566362/201153175-a1788a63-704c-4f21-8e1a-f44b7160bace.png" alt="image"></p><h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>有时用户希望将我们的报表页面分享到其他的渠道，比如邮件、PPT等，每次都需要自己截图，一是很麻烦，二是截出来的图大小不一。</p><p>有没有办法在页面提供一个下载报表页面的功能，用户只需要点击按钮，就自动将当前的报表页面以图片形式下载下来呢？</p><p>html2canvas库就能帮我们做到，无需后台支持，纯浏览器实现截图，即使页面有滚动条也是没问题的，截出来的图非常清晰。</p><p>这个库的维护时间非常长，早在2013年9月8日它就发布了第一个版本，比Vue的第一个版本（2013年12月8日）还要早。</p><p>截止到今天2020年12月18日，html2canvas库在github已经有22.3k star，在npm的周下载量也有506k，非常了不起！</p><p>上一次提交是在2020年8月9日，可见作者依然在很热情地维护着这个库，而且用TypeScript重构过，不过这个库的作者非常保守，哪怕已经持续不断地维护了7年，他在README里依然提到这个库目前还在实验阶段，不建议在生产环境使用。</p><p>事实上我很早就将这个库用在了生产环境，这篇文章就来分析下这个神奇和了不起的JavaScript库，看看它是怎么实现浏览器端截图的。</p><h2 id="_1-如何使用" tabindex="-1">1 如何使用 <a class="header-anchor" href="#_1-如何使用" aria-label="Permalink to &quot;1 如何使用&quot;">​</a></h2><p>在介绍html2canvas的原理之前，先来看看怎么使用它，使用起来真的非常简单，几乎是1分钟上手。</p><p>使用html2canvas只要以下3步：</p><ol><li>安装</li><li>引入</li><li>调用</li></ol><h3 id="_1-1-step-1-安装" tabindex="-1">1.1 Step 1: 安装 <a class="header-anchor" href="#_1-1-step-1-安装" aria-label="Permalink to &quot;1.1 Step 1: 安装&quot;">​</a></h3><div class="language-shell"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">i</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">html2canvas</span></span></code></pre></div><h3 id="_1-2-step-2-引入" tabindex="-1">1.2 Step 2: 引入 <a class="header-anchor" href="#_1-2-step-2-引入" aria-label="Permalink to &quot;1.2 Step 2: 引入&quot;">​</a></h3><p>随便在一个现代框架的工程项目中引入html2canvas</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#BABED8;"> html2canvas </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">html2canvas</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h3 id="_1-3-step-3-截图并下载" tabindex="-1">1.3 Step 3: 截图并下载 <a class="header-anchor" href="#_1-3-step-3-截图并下载" aria-label="Permalink to &quot;1.3 Step 3: 截图并下载&quot;">​</a></h3><p>html2canvas就是一个函数，在页面渲染完成之后直接调用即可。</p><p>视图渲染完成的事件：</p><ol><li>Angular的ngAfterViewInit方法</li><li>React的componentDidMount方法</li><li>Vue的mounted方法 可以只传一个参数，就是你要截图的DOM元素，该函数返回一个Promise对象，在它的then方法中可以获取到绘制好的canvas对象，通过调用canvas对象的toDataURL方法就可以将其转换成图片。</li></ol><p>拿到图片的URL之后，我们可以</p><p>将其放到<code>&lt;img&gt;</code>标签的src属性中，让其显示在网页中； 也可以将其放到<code>&lt;a&gt;</code>标签的href属性中，将该图片下载到本地磁盘中。 我们选择后者。</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">html2canvas</span><span style="color:#BABED8;">(document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">.main</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">))</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#BABED8;">(</span><span style="color:#BABED8;font-style:italic;">canvas</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">link</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createElement</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">a</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 创建一个超链接对象实例</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">event</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">MouseEvent</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">click</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 创建一个鼠标事件的实例</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#BABED8;">link</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">download</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Button.png</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 设置要下载的图片的名称</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#BABED8;">link</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">href</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">canvas</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">toDataURL</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 将图片的URL设置到超链接的href中</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#BABED8;">link</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">dispatchEvent</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">event</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 触发超链接的点击事件</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>是不是非常简单？</p><h3 id="参数" tabindex="-1">参数 <a class="header-anchor" href="#参数" aria-label="Permalink to &quot;参数&quot;">​</a></h3><p>我们再来大致看一眼它的API，该函数的签名如下：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">html2canvas</span><span style="color:#BABED8;">(element: HTMLElement</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> options: object): </span><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">&lt;</span><span style="color:#BABED8;">HTMLCanvasElement</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>options对象可选的值如下：</p><table><thead><tr><th>Name</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>allowTaint</td><td>false</td><td>是否允许跨域图像污染画布</td></tr><tr><td>backgroundColor</td><td>#ffffff</td><td>画布背景颜色，如果在DOM中没有指定，设置“null”（透明）</td></tr><tr><td>canvas</td><td>null</td><td>使用现有的“画布”元素，用来作为绘图的基础</td></tr><tr><td>foreignObjectRendering</td><td>false</td><td>是否使用ForeignObject渲染（如果浏览器支持的话）</td></tr><tr><td>imageTimeout</td><td>15000</td><td>加载图像的超时时间(毫秒)，设置为“0”以禁用超时</td></tr><tr><td>ignoreElements</td><td>(element) =&gt; false</td><td>从呈现中移除匹配元素</td></tr><tr><td>logging</td><td>true</td><td>为调试目的启用日志记录</td></tr><tr><td>onclone</td><td>null</td><td>回调函数，当文档被克隆以呈现时调用，可以用来修改将要呈现的内容，而不影响原始源文档。</td></tr><tr><td>proxy</td><td>null</td><td>用来加载跨域图片的代理URL，如果设置为空（默认），跨域图片将不会被加载</td></tr><tr><td>removeContainer</td><td>true</td><td>是否清除html2canvas临时创建的克隆DOM元素</td></tr><tr><td>scale</td><td>window.devicePixelRatio</td><td>用于渲染的缩放比例，默认为浏览器设备像素比</td></tr><tr><td>useCORS</td><td>false</td><td>是否尝试使用CORS从服务器加载图像</td></tr><tr><td>width</td><td>Element width</td><td>canvas的宽度</td></tr><tr><td>height</td><td>Element height</td><td>canvas的高度</td></tr><tr><td>x</td><td>Element x-offset</td><td>canvas的x轴位置</td></tr><tr><td>y</td><td>Element y-offset</td><td></td></tr><tr><td>scrollX</td><td>Element scrollX</td><td>渲染元素时使用的x轴位置(例如，如果元素使用position: fixed)</td></tr><tr><td>scrollY</td><td>Element scrollY</td><td>渲染元素时使用的y轴位置(例如，如果元素使用position: fixed)</td></tr><tr><td>windowWidth</td><td>Window.innerWidth</td><td>渲染元素时使用的窗口宽度，这可能会影响诸如媒体查询之类的事情</td></tr><tr><td>windowHeight</td><td>Window.innerHeight</td><td>渲染元素时使用的窗口高度，这可能会影响诸如媒体查询之类的事情</td></tr></tbody></table><h3 id="忽略元素" tabindex="-1">忽略元素 <a class="header-anchor" href="#忽略元素" aria-label="Permalink to &quot;忽略元素&quot;">​</a></h3><p>options有一个ignoreElements参数可以用来忽略某些元素，从渲染过程中移除，除了设置该参数外，还有一种忽略元素的方法，就是在需要忽略的元素上增加data-html2canvas-ignore属性。</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">data-html2canvas-ignore</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;">Ignore element</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><h2 id="_2-基本原理" tabindex="-1">2 基本原理 <a class="header-anchor" href="#_2-基本原理" aria-label="Permalink to &quot;2 基本原理&quot;">​</a></h2><p>介绍完html2canvas的使用，我们先来了解下它的基本原理，然后再分析细节实现。</p><p>它的基本原理其实很简单，就是去读取已经渲染好的DOM元素的结构和样式信息，然后基于这些信息去构建截图，呈现在canvas画布中。</p><p>它无法绕过浏览器的内容策略限制，如果要呈现跨域图片，需要设置一个代理。</p><h2 id="_3-主流程-html2canvas方法" tabindex="-1">3 主流程 html2canvas方法 <a class="header-anchor" href="#_3-主流程-html2canvas方法" aria-label="Permalink to &quot;3 主流程 html2canvas方法&quot;">​</a></h2><p>基本原理很简单，但源码里面其实东西很多，我们一步一步来，先找到入口，然后慢慢调试，走一遍大致的流程。</p><h3 id="寻找入口文件" tabindex="-1">寻找入口文件 <a class="header-anchor" href="#寻找入口文件" aria-label="Permalink to &quot;寻找入口文件&quot;">​</a></h3><p>拉取到源码，有很多方法可以找到入口文件：</p><ul><li>方法一：最简单的方法是直接全局搜索html2canvas，这种方法效率很低，而且要碰运气，不推荐</li><li>方法二：在项目中引入这个库，调用它，跑起来，并在该方法前面打断点进行调试，一般能精确地找到入口文件，推荐</li><li>方法三：观察下是否有webpack.config.js或者rollup.config.js的构建工具的配置文件，然后在配置文件中找到精确的入口文件（一般是entry或input之类的属性），推荐</li><li>方法四：直接扫一眼目录结构，一般入口文件在src/core/packages之类的目录下，文件名是index或者main，或者是模块的名字，有经验的话可以用这个方法，找起来很快，强烈推荐</li></ul><h4 id="方法一-全局搜索" tabindex="-1">方法一：全局搜索 <a class="header-anchor" href="#方法一-全局搜索" aria-label="Permalink to &quot;方法一：全局搜索&quot;">​</a></h4><p>最简单最容易想到的的方法，就是全局搜索关键字html2canvas，因为我们在不了解html2canvas的实现之前，我们接触到的关键字就只有这一个。</p><p>但是全局搜索运气不好的话，很可能搜出来很多结果，在里面找入口文件费时费力，比如： <img src="https://segmentfault.com/img/remote/1460000038551338" alt=""></p><p>42个文件285个结果，找起来很麻烦，不推荐。</p><h4 id="方法二-打断点" tabindex="-1">方法二：打断点 <a class="header-anchor" href="#方法二-打断点" aria-label="Permalink to &quot;方法二：打断点&quot;">​</a></h4><p>在调用html2canvas的地方打一个断点。 <img src="https://segmentfault.com/img/remote/1460000038551335" alt=""></p><p>然后在执行到断点处时，点击向下的小箭头，进入该方法。</p><p><img src="https://segmentfault.com/img/remote/1460000038551339" alt=""></p><p>因为在开发环境，很快我们就能发现入口文件和入口方法在哪儿，这里显示的是html2canvas文件，实际上这个文件是构建之后的文件，但是这个文件的上下文给我们提供了找入口方法的信息，这里我们发现了renderElement方法。</p><p><img src="https://segmentfault.com/img/remote/1460000038551332" alt=""></p><p>这时我们可以尝试全局搜索这个方法，很幸运直接找到了😄</p><p><img src="https://segmentfault.com/img/remote/1460000038551336" alt=""></p><h4 id="方法三-找配置文件" tabindex="-1">方法三：找配置文件 <a class="header-anchor" href="#方法三-找配置文件" aria-label="Permalink to &quot;方法三：找配置文件&quot;">​</a></h4><p>寻找配置文件一般也要靠经验，一般配置文件都会带.config后缀常见构建工具的配置文件：</p><p>构建工具 配置文件 Webpack webpack.config.js Rollup rollup.config.js Gulp glupfile.config.js Grunt Gruntfile.js 配置文件找到，入口文件一般很容易就找到</p><p><img src="https://segmentfault.com/img/remote/1460000038551331" alt=""></p><h4 id="方法四" tabindex="-1">方法四： <a class="header-anchor" href="#方法四" aria-label="Permalink to &quot;方法四：&quot;">​</a></h4><p>方法四一般也要靠经验，我们扫一眼目录结构，其实很容易就能发现主入口src/index.ts</p><p><img src="https://segmentfault.com/img/remote/1460000038551334" alt=""></p><h3 id="从主入口出发" tabindex="-1">从主入口出发 <a class="header-anchor" href="#从主入口出发" aria-label="Permalink to &quot;从主入口出发&quot;">​</a></h3><p>我们已经找到了入口方法在src/index.ts文件中，先从主入口出发，把大致的调用关系梳理出来，对全局有个基本的了解，然后再深入细节。</p><p>入口方法几乎啥也没做，直接返回了另一个方法renderElement的调用结果。</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 入口方法</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> html2canvas </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">element</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">HTMLElement</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">options</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Partial</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Options</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{}):</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">HTMLCanvasElement</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">renderElement</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">element</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">options</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><p>沿着调用关系往下，很快我们就梳理出了如下简易火焰图（带方法注释） <img src="https://segmentfault.com/img/remote/1460000038551333" alt=""></p><p>这张简易的火焰图主要有两点需要注意：</p><ol><li>简易火焰图只是帮助我们对整个流程有个粗略的认识，这种认识既不细致也不全面，需要进一步分析里面的关键方法</li><li>renderStackContent这个渲染层叠内容的方法是整个html2canvas最核心的方法，我们将在4 渲染层叠内容一章中单独分析</li></ol><h3 id="将页面中指定的dom元素渲染到离屏canvas中-renderelement" tabindex="-1">将页面中指定的DOM元素渲染到离屏canvas中 renderElement <a class="header-anchor" href="#将页面中指定的dom元素渲染到离屏canvas中-renderelement" aria-label="Permalink to &quot;将页面中指定的DOM元素渲染到离屏canvas中 renderElement&quot;">​</a></h3><p>通过简易火焰图，我们已经对html2canvas的主流程有了一个基本的认识，接下来我们一层一层来分析，先看renderElement方法。</p><p>这个方法的主要目的是将页面中指定的DOM元素渲染到一个离屏canvas中，并将渲染好的canvas返回给用户。</p><p>它主要做了以下事情：</p><ol><li>解析用户传入的options，将其与默认的options合并，得到用于渲染的配置数据renderOptions</li><li>对传入的DOM元素进行解析，取到节点信息和样式信息，这些节点信息会和上一步的renderOptions配置一起传给canvasRenderer实例，用来绘制离屏canvas</li><li>canvasRenderer将依据浏览器渲染层叠内容的规则，将用户传入的DOM元素渲染到一个离屏canvas中，这个离屏canvas我们可以在then方法的回调中取到</li></ol><p>renderElement方法的核心代码如下：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> renderElement </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">async</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">element</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">HTMLElement</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">opts</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Partial</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Options</span><span style="color:#89DDFF;">&gt;):</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">HTMLCanvasElement</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">renderOptions</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{...</span><span style="color:#BABED8;">defaultOptions</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">...</span><span style="color:#BABED8;">opts</span><span style="color:#89DDFF;">};</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 合并默认配置和用户配置</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">renderer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">CanvasRenderer</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">renderOptions</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 根据渲染的配置数据生成canvasRenderer实例</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">root</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">parseTree</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">element</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 解析用户传入的DOM元素（为了不影响原始的DOM，实际上会克隆一个新的DOM元素），获取节点信息</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">renderer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">render</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">root</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// canvasRenderer实例会根据解析到的节点信息，依据浏览器渲染层叠内容的规则，将DOM元素内容渲染到离屏canvas中</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><p>合并配置的逻辑比较简单，我们直接略过，重点分析下解析节点信息（parseTree）和渲染离屏canvas（renderer.render）两个逻辑。</p><h3 id="解析节点信息-parsetree" tabindex="-1">解析节点信息 parseTree <a class="header-anchor" href="#解析节点信息-parsetree" aria-label="Permalink to &quot;解析节点信息 parseTree&quot;">​</a></h3><p>parseTree的入参就是一个普通的DOM元素，返回值是一个ElementContainer对象，该对象主要包含DOM元素的位置信息（bounds: width|height|left|top）、样式数据、文本节点数据等（只是节点树的相关信息，不包含层叠数据，层叠数据在parseStackingContexts方法中取得）。</p><p>解析的方法就是递归整个DOM树，并取得每一层节点的数据。</p><p>ElementContainer对象是一颗树状结构，大致如下：</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  bounds</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;">height</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1303.6875</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> left</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">8</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> top</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">-298.5625</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> width</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1273</span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#BABED8;">  elements</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">      bounds</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;">left</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">8</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> top</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">-298.5625</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> width</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1273</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> height</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1303.6875</span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#BABED8;">      elements</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">          bounds</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;">left</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">8</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> top</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">-298.5625</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> width</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1273</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> height</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1303.6875</span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#BABED8;">          elements</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span></span>
<span class="line"><span style="color:#BABED8;">            </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;">styles</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> CSSParsedDeclaration</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> textNodes</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> elements</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">0</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> bounds</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Bounds</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> flags</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#BABED8;">            </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;">styles</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> CSSParsedDeclaration</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> textNodes</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> elements</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">0</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> bounds</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Bounds</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> flags</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#BABED8;">            </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;">styles</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> CSSParsedDeclaration</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> textNodes</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> elements</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">0</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> bounds</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Bounds</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> flags</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#BABED8;">            </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;">styles</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> CSSParsedDeclaration</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> textNodes</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">3</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> elements</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">2</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> bounds</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Bounds</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> flags</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#BABED8;">            ...</span></span>
<span class="line"><span style="color:#BABED8;">          </span><span style="color:#89DDFF;">],</span></span>
<span class="line"><span style="color:#BABED8;">          flags</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">          styles</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;">backgroundClip</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> backgroundColor</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> backgroundImage</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">0</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> backgroundOrigin</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> backgroundPosition</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> …</span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#BABED8;">          textNodes</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[]</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#BABED8;">      </span><span style="color:#89DDFF;">],</span></span>
<span class="line"><span style="color:#BABED8;">      flags</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">      styles</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> CSSParsedDeclaration </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;">backgroundClip</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> backgroundColor</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> backgroundImage</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">0</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> backgroundOrigin</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> backgroundPosition</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> …</span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#BABED8;">      textNodes</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[]</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">],</span></span>
<span class="line"><span style="color:#BABED8;">  flags</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#BABED8;">  styles</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> CSSParsedDeclaration </span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;">backgroundClip</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> backgroundColor</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> backgroundImage</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">0</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> backgroundOrigin</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> backgroundPosition</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> Array(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> …</span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#BABED8;">  textNodes</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>里面包含了每一层节点的：</p><ul><li>bounds - 位置信息（宽/高、横/纵坐标）</li><li>elements - 子元素信息</li><li>flags - 用来决定如何渲染的标志</li><li>styles - 样式描述信息</li><li>textNodes - 文本节点信息</li></ul><h3 id="渲染离屏canvas-renderer-render" tabindex="-1">渲染离屏canvas renderer.render <a class="header-anchor" href="#渲染离屏canvas-renderer-render" aria-label="Permalink to &quot;渲染离屏canvas renderer.render&quot;">​</a></h3><p>有了节点树信息，就可以用来渲染离屏canvas了，我们来看看渲染的逻辑。</p><p>渲染的逻辑在CanvasRenderer类的render方法中，该方法主要用来渲染层叠内容：</p><ol><li>使用上一步解析到的节点数据，生成层叠数据</li><li>使用节点的层叠数据，依据浏览器渲染层叠数据的规则，将DOM元素一层一层渲染到离屏canvas中</li></ol><p>render方法的核心代码如下：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">async </span><span style="color:#82AAFF;">render</span><span style="color:#BABED8;">(element: ElementContainer): </span><span style="color:#FFCB6B;">Promise</span><span style="color:#89DDFF;">&lt;</span><span style="color:#BABED8;">HTMLCanvasElement</span><span style="color:#89DDFF;">&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#676E95;font-style:italic;">/**</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">   * StackingContext {</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">   *   element: ElementPaint {container: ElementContainer, effects: Array(0), curves: BoundCurves}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">   *   inlineLevel: []</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">   *   negativeZIndex: []</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">   *   nonInlineLevel: [ElementPaint]</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">   *   nonPositionedFloats: []</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">   *   nonPositionedInlineLevel: []</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">   *   positiveZIndex: [StackingContext]</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">   *   zeroOrAutoZIndexOrTransformedOrOpacity: [StackingContext]</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">   * }</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">   */</span></span>
<span class="line"><span style="color:#BABED8;">  const stack </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">parseStackingContexts</span><span style="color:#BABED8;">(element);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 渲染层叠内容</span></span>
<span class="line"><span style="color:#BABED8;">  await this.renderStack(stack);</span></span>
<span class="line"><span style="color:#BABED8;">  return this.canvas;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>其中的</p><ul><li>inlineLevel - 内联元素</li><li>negativeZIndex - zIndex为负的元素</li><li>nonInlineLevel - 非内联元素</li><li>nonPositionedFloats - 未定位的浮动元素</li><li>nonPositionedInlineLevel - 内联的非定位元素，包含内联表和内联块</li><li>positiveZIndex - z-index大于等于1的元素</li><li>zeroOrAutoZIndexOrTransformedOrOpacity - 所有有层叠上下文的（z-index: auto|0）、透明度小于1的（opacity小于1）或变换的（transform不为none）元素</li></ul><p>代表的是层叠信息，渲染层叠内容时会根据这些层叠信息来决定渲染的顺序，一层一层有序进行渲染。</p><p>parseStackingContexts解析层叠信息的方式和parseTree解析节点信息的方式类似，都是递归整棵树，收集树的每一层的信息，形成一颗包含层叠信息的层叠树。</p><p>而渲染层叠内容的renderStack方式实际上调用的是renderStackContent方法，该方法是整个渲染流程中最为关键的方法，下一章单独分析。</p><h2 id="_4-渲染层叠内容-renderstackcontent" tabindex="-1">4 渲染层叠内容 renderStackContent <a class="header-anchor" href="#_4-渲染层叠内容-renderstackcontent" aria-label="Permalink to &quot;4 渲染层叠内容 renderStackContent&quot;">​</a></h2><p>将DOM元素一层一层得渲染到离屏canvas中，是html2canvas所做的最核心的事情，这件事由renderStackContent方法来实现。</p><p>因此有必要重点分析这个方法的实现原理，这里涉及到CSS布局相关的一些知识，我先做一个简单的介绍。</p><h3 id="css层叠布局规则" tabindex="-1">CSS层叠布局规则 <a class="header-anchor" href="#css层叠布局规则" aria-label="Permalink to &quot;CSS层叠布局规则&quot;">​</a></h3><p>默认情况下，CSS是流式布局的，元素与元素之间不会重叠。</p><blockquote><p>流式布局的意思可以理解：在一个矩形的水面上，放置很多矩形的浮块，浮块会漂浮在水面上，且彼此之间依次排列，不会重叠在一起 这是要绘制它们其实非常简单，一个个按顺序绘制即可。</p></blockquote><p>不过有些情况下，这种流式布局会被打破，比如使用了浮动(float)和定位(position)。</p><p>因此需要需要识别出哪些脱离了正常文档流的元素，并记住它们的层叠信息，以便正确地渲染它们。</p><p>那些脱离正常文档流的元素会形成一个层叠上下文，可以将层叠上下文简单理解为一个个的薄层（类似Photoshop的图层），薄层中有很多DOM元素，这些薄层叠在一起，最终形成了我们看到的多彩的页面。</p><p>这些不同类型的层的层叠顺序规则如下：</p><p><img src="https://segmentfault.com/img/remote/1460000038551337" alt=""></p><p>这张图很重要，html2canvas渲染DOM元素的规则也是一样的，可以认为html2canvas就是对这张图描述的规则的一个实现。</p><p>详细的规则在w3官方文档中有描述，大家可以参考： <a href="https://www.w3.org/TR/css-position-3/#painting-order" target="_blank" rel="noreferrer">https://www.w3.org/TR/css-position-3/#painting-order</a></p><h3 id="renderstackcontent就是对css层叠布局规则的一个实现" tabindex="-1">renderStackContent就是对CSS层叠布局规则的一个实现 <a class="header-anchor" href="#renderstackcontent就是对css层叠布局规则的一个实现" aria-label="Permalink to &quot;renderStackContent就是对CSS层叠布局规则的一个实现&quot;">​</a></h3><p>有了这些基础知识，我们分析renderStackContent就一目了然了，它的源码如下：</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">async </span><span style="color:#82AAFF;">renderStackContent</span><span style="color:#BABED8;">(stack: StackingContext) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 1. 最底层是background/border</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">renderNodeBackgroundAndBorders</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">stack</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">element</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 2. 第二层是负z-index</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">child</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">of</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">stack</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">negativeZIndex</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">renderStack</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">child</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 3. 第三层是block块状盒子</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">renderNodeContent</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">stack</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">element</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">child</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">of</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">stack</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">nonInlineLevel</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">renderNode</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">child</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 4. 第四层是float浮动盒子</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">child</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">of</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">stack</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">nonPositionedFloats</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">renderStack</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">child</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 5. 第五层是inline/inline-block水平盒子</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">child</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">of</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">stack</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">nonPositionedInlineLevel</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">renderStack</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">child</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">child</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">of</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">stack</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">inlineLevel</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">renderNode</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">child</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 6. 第六层是以下三种：</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// (1) ‘z-index: auto’或‘z-index: 0’。</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// (2) ‘transform: none’</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// (3) opacity小于1</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">child</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">of</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">stack</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">zeroOrAutoZIndexOrTransformedOrOpacity</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">renderStack</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">child</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 7. 第七层是正z-index</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">child</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">of</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">stack</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">positiveZIndex</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">renderStack</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">child</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>本文主要介绍html2canvas实现浏览器截图的原理。</p><p>首先简单介绍html2canvas是做什么的，如何使用它；</p><p>然后从主入口出发，分析html2canvas渲染DOM元素的大致流程（简易火焰图）；</p><p>接着按火焰图的顺序，依次对renderElement方法中执行的parseTree/parseStackingContextrenderer.render三个方法进行分析，了解这些方法的作用和原理；</p><p>最后通过介绍CSS布局规则和7阶层叠水平，自然地引出renderStackContent关键方法实现原理的介绍。</p>`,118);function c(y,D,F,i,B,d){const s=n("EditInfo");return l(),o("div",null,[r,p(s,{time:"2020年12月20日 16:41",title:"阅读 3398 ·  点赞 74 ·  评论 10 ·  收藏 110"})])}const h=a(e,[["render",c]]);export{E as __pageData,h as default};

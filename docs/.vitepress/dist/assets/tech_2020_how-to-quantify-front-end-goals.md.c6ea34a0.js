import{_ as t,B as a,o as p,c as o,G as l,Q as c}from"./chunks/framework.1fee3549.js";const g=JSON.parse('{"title":"立完flag，你可能需要对flag进行量化","description":"","frontmatter":{},"headers":[],"relativePath":"tech/2020/how-to-quantify-front-end-goals.md","filePath":"tech/2020/how-to-quantify-front-end-goals.md"}'),r={name:"tech/2020/how-to-quantify-front-end-goals.md"},s=c('<h1 id="立完flag-你可能需要对flag进行量化" tabindex="-1">立完flag，你可能需要对flag进行量化 <a class="header-anchor" href="#立完flag-你可能需要对flag进行量化" aria-label="Permalink to &quot;立完flag，你可能需要对flag进行量化&quot;">​</a></h1><p><img src="https://user-images.githubusercontent.com/9566362/201154182-6214a691-a122-4170-8fb6-46ce8c1661f4.png" alt="image"></p><h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>当你的能力足够，并且获得领导的信任之后，很自然地就会去承担更大、更重要的责任，比如成为大中型业务的Owner。</p><p>大中型业务指的是该业务足够大，足够复杂，仅凭一己之力无法按要求交付版本，需要团队协作。</p><p>我们假设该业务一共12个人，其中角色分布如下（按产品研发流程排序）：</p><table><thead><tr><th>角色</th><th>职责</th><th>成员数</th></tr></thead><tbody><tr><td>产品经理</td><td>对接用户，是需求的来源</td><td>1</td></tr><tr><td>项目经理</td><td>管理项目进度，有节奏地进行版本交付</td><td>1</td></tr><tr><td>设计</td><td>负责UI交互和视觉，是用户体验的设计者</td><td>1</td></tr><tr><td>前端</td><td>前端用户界面和交互效果开发</td><td>3</td></tr><tr><td>后台</td><td>后台数据存储和接口开发</td><td>4</td></tr><tr><td>测试</td><td>负责版本质量</td><td>1</td></tr><tr><td>运维</td><td>负责现网部署</td><td>1</td></tr></tbody></table><p>如果你被分到该业务，成为前端Owner，你可能需要做些什么，以高效率、高质量地实现版本交付呢？</p><h2 id="_1-明确目标和职责" tabindex="-1">1 明确目标和职责 <a class="header-anchor" href="#_1-明确目标和职责" aria-label="Permalink to &quot;1 明确目标和职责&quot;">​</a></h2><p>首先要了解组织和领导对你的期望，假设组织希望你能够改善该业务的交付质量，赢得用户口碑。</p><p>目标非常明确，就是提升<code>交付质量</code>，这个目标将牵引你未来一年的方向和行为，也是你超预期完成目标的前提。</p><p>有了目标之后，我们还需要去衡量它，这样才知道有没有提升，尽量寻找可以量化的指标。</p><p>这一块可以参考我们以前的文章：<a href="https://juejin.cn/post/6844904095908626445" target="_blank" rel="noreferrer">《如何度量前端项目研发效率与质量》</a></p><h2 id="_2-交付质量的组成" tabindex="-1">2 交付质量的组成 <a class="header-anchor" href="#_2-交付质量的组成" aria-label="Permalink to &quot;2 交付质量的组成&quot;">​</a></h2><p>质量代表的是好不好，问题越少就越好。</p><p>从产品侧来看，<code>缺陷率</code>和<code>JS错误率</code>都是非常不错的衡量指标。</p><p>从开发侧来看也有很多很好的衡量指标，比如：</p><ul><li><code>重复率</code></li><li><code>圈复杂度</code></li><li><code>ESLint问题数</code></li><li><code>巨石文件/方法数</code></li></ul><h2 id="_3-计算缺陷率" tabindex="-1">3 计算缺陷率 <a class="header-anchor" href="#_3-计算缺陷率" aria-label="Permalink to &quot;3 计算缺陷率&quot;">​</a></h2><blockquote><p>缺陷率=缺陷数/代码规模</p></blockquote><p>缺陷也就是BUG，当我们开发完产品特性后，需要部署到测试环境，并提测，测试人员测试完，会提一堆BUG单，这些BUG的数量就是缺陷数。</p><p>代码规模可以用代码行数来表示，一般源码都放在工程根目录下的src目录中，可以使用<a href="https://github.com/AlDanial/cloc" target="_blank" rel="noreferrer">cloc</a>工具统计代码行数：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">cloc src</span></span></code></pre></div><p>如果要排除里面的某些目录，比如<code>__tests__</code>，可以加上<code>--exclude-dir</code>参数</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">cloc src --exclude-dir=__tests__</span></span></code></pre></div><p>比如<code>html2canvas</code>库的代码行数：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97c93aa2e9724d58830b171b795f2525~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>有了缺陷数和代码规模，就可以计算缺陷率啦。</p><p>可以先统计下历史迭代的缺陷率，缺陷数可以通过查看<code>测试报告</code>获得，该版本增加的代码行数可以通过<code>Git提交记录</code>获得。</p><p>比如上一个<code>迭代1.2.6</code>，从<code>2020.12.14-2020.12.25</code>。</p><p>我们可以使用以下命令统计到新增的代码行数：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">git log --after=&quot;2020-12-14 00:00:00&quot; --before=&quot;2020-12-25 23:59:59&quot; --pretty=tformat: --numstat | grep -v &#39;static&#39; | awk &#39;{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf &quot;增加行数:%s 删除行数:%s 变化总行数:%s\\n&quot;,add,subs,loc }&#39;</span></span></code></pre></div><p>还是以html2canvas举栗子🌰</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96eebc2e4eb7463fb1e387b244600ac4~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>假设通过查看测试报告，这段时间一共出了3个BUG，那么缺陷率就是：</p><blockquote><p>缺陷率=缺陷数/代码规模=3/130=2.3%</p></blockquote><p>也就是上个迭代的缺陷率为<code>2.3%</code>，我们可以多计算几个迭代，然后算个平均数，这样我们就知道以前这个业务的缺陷率水平大致如何。</p><p>这样你作为业务Owner，后续通过一系列举措，最后降低了这个指标，假设降低到<code>1.8%</code>，那么可以认为质量提升了：</p><blockquote><p>(2.3-1.8)/2.3=21.7%</p></blockquote><h2 id="_4-监控js错误率" tabindex="-1">4 监控JS错误率 <a class="header-anchor" href="#_4-监控js错误率" aria-label="Permalink to &quot;4 监控JS错误率&quot;">​</a></h2><p>第二个是JS错误率，就是监控现网用户访问页面时，是否有JS报错，如果有JS报错，很可能某些功能就可用。</p><p>我们没法在用户的现场，我们不知道用户使用我们产品的体验如何，他是否在使用过程中遇到了困难，这些我们没法直接知道。</p><p>但是JS报错给我们提供了一些了解这些信息的线索，假设某个时刻，现网出现了JS报错，我们或许就能复现这个报错，找到报错的原因，并在用户投诉之前及时修复这个缺陷。</p><p>可以说:</p><blockquote><p>降低现网JS错误率就是在排除地雷，地雷越少，炸到的用户就越少，这对产品的用户口碑意义重大</p></blockquote><p>这个指标需要通过前端监控平台采集，比如我们DevUI内部的Furion平台，它的计算公式如下：</p><blockquote><p>JS错误率=JS错误数/PV</p></blockquote><p>也是先看下以往的现网JS错误率水平，假设是<code>6.2%</code>，你通过努力将这个指标降到<code>0.1%</code>，那么质量提升就是<code>98%</code>。</p><h2 id="_5-统计重复率" tabindex="-1">5 统计重复率 <a class="header-anchor" href="#_5-统计重复率" aria-label="Permalink to &quot;5 统计重复率&quot;">​</a></h2><p>除了产品层面的质量衡量指标，我们还可以设定一些开发侧的质量指标。</p><p>重复率就是一个很不错的指标，如果项目里面重复的代码太多</p><ul><li>一来我们的维护成本提高，一处变更，要改很多地方；</li><li>二来容易漏该某些地方，从来导致BUG。</li></ul><blockquote><p>重复代码是万恶之源</p></blockquote><p>我们可以用<a href="https://github.com/kucherenko/jscpd" target="_blank" rel="noreferrer">jscpd</a>工具来统计前端代码的重复率：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">jscpd src</span></span></code></pre></div><p>以html2canvas为🌰</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18949f9409fb4d47a0e0448d71b64c18~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>它一共有14处重复代码，重复率为<code>1.71%</code>（算比较低的），jscpd命令还会列出每一处重复所在的文件以及所在的行/列。</p><p>我们要做的就是照着重复率报告，一处一处改掉即可，当然修改重复代码也要考虑可读性，不能为了消除重复，降低了代码的可读性。</p><p>假设改完之后，重复率降到<code>1.16%</code>，那么质量提升了<code>32%</code>。</p><h2 id="_6-计算圈复杂度" tabindex="-1">6 计算圈复杂度 <a class="header-anchor" href="#_6-计算圈复杂度" aria-label="Permalink to &quot;6 计算圈复杂度&quot;">​</a></h2><p>圈复杂度可以参考下我们之前的文章：<a href="https://juejin.cn/post/6844904161809580045" target="_blank" rel="noreferrer">浅谈前端中的圈复杂度 </a>，这里就不赘述。</p><h2 id="_7-eslint问题数清零" tabindex="-1">7 ESLint问题数清零 <a class="header-anchor" href="#_7-eslint问题数清零" aria-label="Permalink to &quot;7 ESLint问题数清零&quot;">​</a></h2><p><a href="https://github.com/eslint/eslint" target="_blank" rel="noreferrer">ESLint</a>通过一些最佳实践的规范，来约束我们的代码，从而保障代码质量。</p><p>下图清晰地展示了ESLint的价值：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18ef0655bc654b62bd285d4d6bf9f1c1~tplv-k3u1fbpfcp-watermark.image" alt=""></p><ul><li>如果你不使用ESLint，你的代码只能靠人工来检查，格式乱七八糟，运行起来bug丛生，你的合作者或用户会怒气冲冲；</li><li>如果你使用了ESLint，你的代码有可靠的机器进行检查，格式规则，运行起来问题会少很多，大家都会很满意。</li></ul><p>如果项目中的代码没有遵循ESLint规则，那么就会产生一条ESLint错误或者提示，将这些ESLint问题修复，在一定程度上是可以提升代码质量的。</p><p>假设ESLint问题清零了，那么质量提升就是<code>100%</code>。</p><h2 id="_8-统计巨石文件-方法数" tabindex="-1">8 统计巨石文件/方法数 <a class="header-anchor" href="#_8-统计巨石文件-方法数" aria-label="Permalink to &quot;8 统计巨石文件/方法数&quot;">​</a></h2><p>大而复杂的事物，我们理解起来一般更费劲，简洁的事物往往易于理解。</p><p>代码也是一样，简单的代码，我们一眼就知道它是做什么的，这样修改它就不容易出错。</p><p>如果一个文件包含几千行代码，或者一个方法包含几百行代码，里面分支众多，嵌套又深，那么我们就很难读懂它，修改它的时候总不免战战兢兢、如履薄冰，还容易出bug。</p><p>统计所有文件的代码行数，并按代码行数从大到小排序，可以使用之前提到的cloc工具：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">cloc src --by-file</span></span></code></pre></div><p>还是以html2canvas为🌰（只截取了代码行数大于100行的文件）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fe0c9ce4aea4b77a52725f54dff8bd3~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>一般一个文件的代码行数不要超过<code>300行</code>，超过300可能就需要进行适当的模块拆分，以增强代码的可读性和可维护性。</p><p>另外也要权衡下文件的嵌套深度，从根路径开始往下，一般不超过<code>7层</code>。</p><p>我目前没想到比较好的统计巨石方法的办法，只能去巨石文件里面找，找到超过<code>50行</code>的方法，我就会考虑重构。</p><p>大家有更好的办法欢迎推荐。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>我们做一个简单的小结，从产品侧来看，可以通过</p><ul><li>缺陷率</li><li>JS错误率 来衡量质量。</li></ul><p>从开发侧来看，可以通过</p><ul><li>重复率</li><li>圈复杂度</li><li>ESLint问题数</li><li>巨石文件/方法 来衡量质量。</li></ul><p>这些质量指标可以根据自己团队的特点和偏好，设定相应的权重，并最终计算出一个总的质量提升比率。</p><p>对目标进行量化之后，我们就可以撸起袖子开干了。</p><blockquote><p>经过一段时间的努力，我们超预期完成了组织的目标，就可以拿着这些质量提升的量化指标去跟组织要年终奖和加薪啦！</p></blockquote><h2 id="加入我们" tabindex="-1">加入我们 <a class="header-anchor" href="#加入我们" aria-label="Permalink to &quot;加入我们&quot;">​</a></h2><p>我们是DevUI团队，欢迎来这里和我们一起打造优雅高效的人机设计/研发体系。招聘邮箱：muyang2@huawei.com。</p><p>文/DevUI Kagol</p><p>往期文章推荐</p><p><a href="https://juejin.cn/post/6844904095908626445" target="_blank" rel="noreferrer">《如何度量前端项目研发效率与质量》</a></p><p><a href="https://juejin.cn/post/6909510287880093704" target="_blank" rel="noreferrer">《现在开始为你的Angular应用编写测试（二）》</a></p><p><a href="https://juejin.cn/post/6904264934515802126" target="_blank" rel="noreferrer">《🏆 DevUI × 掘金 | 技术人的2020》</a></p>',96);function d(n,i,h,u,b,f){const e=a("EditInfo");return p(),o("div",null,[s,l(e,{time:"2020年12月31日 13:00",title:"阅读 1692 ·  点赞 26 ·  评论 1 ·  收藏 14"})])}const k=t(r,[["render",d]]);export{g as __pageData,k as default};

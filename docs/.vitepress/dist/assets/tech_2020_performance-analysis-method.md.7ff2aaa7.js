import{_ as a,B as p,o as t,c as i,G as o,Q as l}from"./chunks/framework.1fee3549.js";const k=JSON.parse('{"title":"在瀑布下用火焰烤饼：三步法助你快速定位网站性能问题","description":"","frontmatter":{},"headers":[],"relativePath":"tech/2020/performance-analysis-method.md","filePath":"tech/2020/performance-analysis-method.md"}'),c={name:"tech/2020/performance-analysis-method.md"},r=l('<h1 id="在瀑布下用火焰烤饼-三步法助你快速定位网站性能问题" tabindex="-1">在瀑布下用火焰烤饼：三步法助你快速定位网站性能问题 <a class="header-anchor" href="#在瀑布下用火焰烤饼-三步法助你快速定位网站性能问题" aria-label="Permalink to &quot;在瀑布下用火焰烤饼：三步法助你快速定位网站性能问题&quot;">​</a></h1><p><img src="https://user-images.githubusercontent.com/9566362/201153043-57f29d9e-b9a5-478a-9586-e4ef601caa2f.png" alt="image"></p><h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>性能，是一个问题。</p><p>每个项目成长到一定的规模，都几乎必然要遇到性能问题，当遇到性能问题时，我们是：</p><blockquote><p>一脸懵逼，就知道很卡、很慢，不知道为什么</p></blockquote><p>还是</p><blockquote><p>能够快速洞察性能瓶颈，找到行之有效的优化方案</p></blockquote><p>取决于我们对性能的理解深浅，以及是否有一套好的工具和方法。</p><p>接下来给大家分享我自己在定位业务性能问题时常用的三步法，为了方便记忆，我把它总结为一句话：</p><blockquote><p>在瀑布下用火焰烤饼</p></blockquote><p>话不多说，喝口水直接开撸！</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85b70bab2d344a27b525f24f47b84b11~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h2 id="performance-面板简介" tabindex="-1">Performance 面板简介 <a class="header-anchor" href="#performance-面板简介" aria-label="Permalink to &quot;Performance 面板简介&quot;">​</a></h2><p>介绍三步法之前，先来简单了解下Chrome开发者工具的Performance性能面板，以及性能分析报告的基本组成。</p><h3 id="生成性能分析报告" tabindex="-1">生成性能分析报告 <a class="header-anchor" href="#生成性能分析报告" aria-label="Permalink to &quot;生成性能分析报告&quot;">​</a></h3><p>以DevUI团队的掘金个人主页为例，使用Chrome浏览器访问：<a href="https://juejin.cn/user/712139267650141" target="_blank" rel="noreferrer">https://juejin.cn/user/712139267650141</a></p><p>然后按F12打开Chrome的开发者工具，选择Performance性能面板。</p><p>这时我们会看到一个简单的指引：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df4ae1be8e02485798f49350f7e57399~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>指引里面有两个按钮，上面的按钮是手动录制，下面的是自动录制，我们点击傻瓜式的自动录制，自动录制会自动刷新页面，在页面加载完成之后，生成该页面的性能分析报告，无需人工干预，非常方便。</p><p>等个几秒钟报告就生成好了，一眼看去，花花绿绿的，不知道从何看起？</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df59c1504dff4751a0e6e7898022f4c4~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="性能报告的组成" tabindex="-1">性能报告的组成 <a class="header-anchor" href="#性能报告的组成" aria-label="Permalink to &quot;性能报告的组成&quot;">​</a></h3><p>我们对生成的性能分析报告做一个简单的面板分类，看起来就很清晰了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26b68ba524b14e949355a3f57ba7aecb~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h4 id="工具栏" tabindex="-1">工具栏 <a class="header-anchor" href="#工具栏" aria-label="Permalink to &quot;工具栏&quot;">​</a></h4><p>性能报告的顶部是一个工具栏（或者叫控制面板），里面有一堆按钮，我这边用得比较多的是前面三个，其中前两个在指引里已经介绍过了，第三个是用来清除报告的。</p><p>还有两个隐藏的功能也很有用，一个是模拟慢网速的，另一个是模拟慢CPU的，对移动端应用做性能优化可能会用到。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f847a37efac64d15a6e379f76df43b2b~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h4 id="概览面板" tabindex="-1">概览面板 <a class="header-anchor" href="#概览面板" aria-label="Permalink to &quot;概览面板&quot;">​</a></h4><p>工具栏下面是一个概览面板，显示了整个页面加载过程中的FPS（Frames Per Second，每秒传输帧数），用来评估页面的流畅度，有大片红色说明页面可能存在卡顿。</p><p>FPS下面是CPU处理各个任务花费的时间，再往下是网络请求的耗时，概览面板最下面是每一帧的截图。</p><h4 id="线程面板" tabindex="-1">线程面板 <a class="header-anchor" href="#线程面板" aria-label="Permalink to &quot;线程面板&quot;">​</a></h4><p>概览面板往下是线程面板，默认展开的是网络请求瀑布图，其他线程的详情都是收起的。</p><p>每个线程面板对性能分析都有价值，而我最常用的是瀑布图和火焰图，后面会重点分析这两个图，如何利用这两张图来分析网站的性能瓶颈。</p><h4 id="内存面板" tabindex="-1">内存面板 <a class="header-anchor" href="#内存面板" aria-label="Permalink to &quot;内存面板&quot;">​</a></h4><p>再往下是内存面板，内存面板需要在控制面板中手动打开，它是一个分类的内存占用折线图。</p><p>每条折线是一种任务随时间推移的内存占用：</p><ul><li>JS堆栈</li><li>文档</li><li>HTML节点</li><li>事件监听</li><li>GPU内存</li></ul><h4 id="详情面板" tabindex="-1">详情面板 <a class="header-anchor" href="#详情面板" aria-label="Permalink to &quot;详情面板&quot;">​</a></h4><p>最下面是详情面板，首先看到的是一个饼图，这个饼图显示了各种类型任务的占比，这个非常有用，能否一眼看出什么类型的任务是性能瓶颈。</p><p>是资源加载还是脚本执行？是页面渲染还是图像绘制？又或者是空闲时间太长？</p><h2 id="第一步-看饼图" tabindex="-1">第一步：看饼图 <a class="header-anchor" href="#第一步-看饼图" aria-label="Permalink to &quot;第一步：看饼图&quot;">​</a></h2><p>刚才介绍Performance面板的组成时，提到了3个非常有用的性能分析利器，分别是<code>详情饼图</code>、<code>请求瀑布图</code>和<code>主线程火焰图</code>。</p><p>我把这三张图总结成一句话：</p><blockquote><p>在瀑布下用火焰烤饼</p></blockquote><p>这句话也是我自己在做性能分析和优化时，屡试不爽的小技巧。</p><p>详情面板中的饼图用于展示各种类型任务的耗时占比。</p><p>主要有以下几种任务：</p><ul><li>蓝色是资源加载</li><li>黄色是脚本执行</li><li>紫色是页面渲染</li><li>绿色是图形绘制</li><li>白色是空闲时间</li></ul><p>还是举刚才的例子。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b6969cf9d9f4540bfd55ef8460e1acb~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>从饼图可以看出占比最多的是<code>脚本执行</code>和<code>空闲</code>。</p><p>脚本执行时间长，我们大概可以猜测里面可能存在长任务（Long task）;</p><p>而空闲占比多可能是等待服务器的响应时间太长。</p><p>饼图可以快速形成基本的判断，而具体原因则需要分析瀑布图和火焰图。</p><h2 id="第二步-看瀑布图" tabindex="-1">第二步：看瀑布图 <a class="header-anchor" href="#第二步-看瀑布图" aria-label="Permalink to &quot;第二步：看瀑布图&quot;">​</a></h2><p>我们来看下请求瀑布图，瀑布图和火焰图都是线程面板的一部分，瀑布图的横轴是时间轴，瀑布图上有很多五颜六色的色块，这些色块就是<code>请求块</code>，每种颜色代表一类资源：</p><ul><li>蓝色是HTML文件</li><li>紫色是CSS文件</li><li>黄色是JavaScript文件</li><li>绿色是图片</li><li>灰色是后台接口</li></ul><p>我们主要关注那些<code>长色块</code>，长色块意味着耗时长，可能是性能瓶颈。</p><p>还是看下掘金个人主页的瀑布图。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a36050601ea4e57adfe2910f26cb457~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="总结瀑布图的特点" tabindex="-1">总结瀑布图的特点 <a class="header-anchor" href="#总结瀑布图的特点" aria-label="Permalink to &quot;总结瀑布图的特点&quot;">​</a></h3><p>我们先观察这张图有什么特点，图形观察能力，相信大家小学就已经培养起来了，大致我们可以总结出以下比较明显的特点：</p><ul><li>特点一：大瀑布被分成三个小瀑布</li><li>特点二：最左边的小瀑布大部分都是黄色色块，中间的小瀑布大部分是灰色色块，最右边的小瀑布大部分是绿色色块</li><li>特点三：前两个瀑布之间有一段间距，中间什么色块都没有</li><li>特点四：后两个瀑布被一个灰色色块的“尾巴”连在了一起</li><li>特点五：顶部有一个超长的灰色色块</li></ul><p>类似的特点我们还可以总结出很多来，但是这些特点说明了什么呢？能否帮助我们定位性能瓶颈呢？</p><p>回答这些问题需要我们对瀑布图以及浏览器原理有很多的认识，我们一步步来分析吧。</p><h3 id="分析瀑布图的含义" tabindex="-1">分析瀑布图的含义 <a class="header-anchor" href="#分析瀑布图的含义" aria-label="Permalink to &quot;分析瀑布图的含义&quot;">​</a></h3><p>我们按从左到右，从上到下的顺序进行分析，最左边有两个色块，一个灰色色块，一个蓝色色块，我们分别点击这两个色块，在详情面板看下它们的详情信息。</p><p>先看灰色色块 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/290be79443c0404ebf4b813c1ef5401d~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>我们有注意到这个请求的启动器（Initiator）是一个Chrome插件：<a href="chrome://new-tab-page/omnibox.mojom-lite.js" target="_blank" rel="noreferrer">chrome://new-tab-page/omnibox.mojom-lite.js</a></p><p>因此我们不关注，接着看蓝色色块 <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad291ed132794851965f3e0b54b89ef5~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>前面我们已经介绍了，蓝色色块代表HTML文件，我们从详情的<code>Mime Type</code>为<code>text/html</code>也可以验证这一点。</p><p>我们滚动鼠标滚轮，把这个瀑布图放大，看这个蓝色请求块的细节</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15437f73032e451bb120ab81c8ffa33e~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h4 id="请求块的组成" tabindex="-1">请求块的组成 <a class="header-anchor" href="#请求块的组成" aria-label="Permalink to &quot;请求块的组成&quot;">​</a></h4><p>通过查看细节图，我们有了新的发现：</p><blockquote><p>每个请求块都由四部分组成：</p><ol><li>左侧线：代表请求发送之前的时间（Before Request Sent）</li><li>浅色块：代表请求已经发送（Request Sent），直到服务器返回第一个字节给浏览器（TTFB, Time to First Byte）</li><li>深色块：服务器返回的内容全部下载到浏览器（Content Download）</li><li>右侧线：等待主线程处理（Waiting for main thread）</li></ol></blockquote><p>这个HTML文件是整个网页渲染的起点，成功请求并下载这个文件，才会有接下来的故事。</p><p>这个请求块的浅色块部分占比比较大，根据前面的介绍，浅色部分代表的是服务器的响应速度，浏览器已经早早地发出了请求，服务器却迟迟才给回应（第一个字节到达浏览器）。</p><p>中间可能是网络慢，也可能是服务器处理速度慢，需要具体排查，毕竟这个HTML文件不算大，才111KBb，却花了179ms。</p><p>对比另外一个文件layouts.default.js，体积比它大124KB，请求耗时却比它小一半多，才74ms。（后来发现这个数据不稳定，这个HTML文件应该不至于构成性能瓶颈）</p><p>另外所有后续的请求都依赖于这个HTML，没有它其他请求都不会发生，它是一个阻塞请求，性能必须要有保障。</p><h4 id="发现可能的性能瓶颈" tabindex="-1">发现可能的性能瓶颈 <a class="header-anchor" href="#发现可能的性能瓶颈" aria-label="Permalink to &quot;发现可能的性能瓶颈&quot;">​</a></h4><p>我们继续看右边的请求块，顶部那个超长的灰色块依然是Chrome插件的请求，我们不管，看下面那一堆黄色的请求块，这些都是JavaScript文件。</p><p>HTML文件下载完了之后，就会开始一行一行解析其中的HTML标签，遇到设置了谁、<code>src</code>属性的<code>&lt;script&gt;</code>标签，就会去下载src指定的JavaScript脚本文件。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcb156ff079249a9b173e86d81f993a5~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>从瀑布图可以看出，一共并行下载了8个JavaScript文件，它们的域名都是一样的：<code>sf1-scmcdn2-tos.pstatp.com</code></p><p>不是说Chrome浏览器对同一个域名，并行的请求数最大是6个吗？</p><p>不仅仅是JavaScript文件，下面还有3个同域名的图片资源，也是在并行请求的，也就是说几乎同时发起了11个请求。</p><p>这说明</p><blockquote><p>掘金的静态资源服务器升级到了HTTP/2</p></blockquote><p>HTTP/2的多路复用可以实现一个TCP连接同时传输多个资源。</p><p>我们到Network面板里去看下这些JavaScript的请求详情，果然和我们猜测的一致，这一点必须给掘金点个赞👍</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b46bad97b1cf46388eae69c2c8cb28ee~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>发一个某86网站和掘金的对比图，大家感受一下</p><p>某86网站： <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bf78ab7422d4334b013439ee622c40b~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>掘金： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/775b17cfce0e4100a777f3b2e03019c6~tplv-k3u1fbpfcp-watermark.image" alt=""></p><blockquote><p>虽然前者更像一个瀑布，但是我喜欢后者丝滑般的体验。</p></blockquote><p>我们再来仔细看这8个请求，相信细致的你一定发现了一个现象：</p><blockquote><ol><li>它们的共同点除了刚才提到的域名一样外，这些请求块的左右线都很短</li><li>有三个特别长的请求块，分别是1/5/8，需要格外关注</li></ol></blockquote><p>请求块的左右线都非常短是一个好现象，说明没有什么等待时间，所有时间都用在了传输数据上。</p><p>我们分别点击1/5/8请求块看它们的详情</p><table><thead><tr><th>请求块</th><th>详情</th></tr></thead><tbody><tr><td>1</td><td>大小：4KB<br>耗时：635ms</td></tr><tr><td>5</td><td>大小：90KB<br>耗时：635ms</td></tr><tr><td>8</td><td>大小：3.9MB<br>耗时：633ms</td></tr></tbody></table><p>这非常奇怪，1/5的资源大小和8的不在一个量级上，耗时却比8还多。</p><p>为了确定这是偶然的，还是必然的，我又录制了两次这个掘金个人主页的性能报告</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1bfaa13151943e3aebffe2984382496~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6af7f771beb142ddaf2edeb9766c4ecf~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>这次和预期的基本一致，8耗时比其他都长，这个JavaScript文件3.9MB，太大了，很可能是性能瓶颈。</p><h4 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h4><p>让我们继续往下分析，黄色JavaScript色块下面一共有三种颜色的色块：</p><ul><li>紫色：CSS样式文件</li><li>绿色：图片文件</li><li>灰色：字体文件（大小为189KB）</li></ul><p>这几个文件体积都不大，并且通过多次生成性能报告，发现这几个请求耗时都不如第8个JavaScript文件长，所以初步判断这些请求不构成性能瓶颈。</p><p>接着看中间那个瀑布，通过多次生成性能报告，发现中间瀑布并没有什么特别耗时的请求，不过不管生成多少次报告，有一点是确定的，就是</p><blockquote><p>这三个瀑布之间总是有些空白</p></blockquote><p>这些空白到底说明了什么呢？</p><p>看完火焰图，相信你就会豁然开朗。</p><h2 id="第三步-看火焰图" tabindex="-1">第三步：看火焰图 <a class="header-anchor" href="#第三步-看火焰图" aria-label="Permalink to &quot;第三步：看火焰图&quot;">​</a></h2><p>在看正式的火焰图之前，先来看一个瀑布图和火焰图放在一起的效果</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6b4db8b54ea46a29e68c37b121813b8~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>看完这张瀑布和火焰的对比图，你一定看出了一个现象</p><blockquote><p>瀑布图有空白的地方，火焰图就有颜色； <br> 瀑布图有颜色的地方，火焰图就是空白。</p></blockquote><p>But Why?</p><p>要回答这个问题需要了解浏览器主线程执行任务的原理，以及火焰图是做什么的，别着急，让我们一步步来分析。</p><h3 id="火焰图是什么" tabindex="-1">火焰图是什么 <a class="header-anchor" href="#火焰图是什么" aria-label="Permalink to &quot;火焰图是什么&quot;">​</a></h3><p>火焰图也是线程面板的一部分，它代表的是浏览器主线程的任务流：</p><blockquote><p>随着页面的加载，时间的推移，主线程依次做了什么事儿</p></blockquote><p>火焰图的横轴是时间，纵轴是一个个的宏任务。</p><p>每个宏任务下面若干个微任务，每个微任务下面有可能有很多子任务，依次类推。</p><p>由于有些任务的嵌套层级深，有些嵌套层级浅，所以呈现倒立的火焰状。</p><p>每种类型的任务颜色都不一样（无需记忆，有个大致的印象即可）：</p><ul><li>解析HTML Parse HTML：蓝色</li><li>解析样式 Parse Stylesheet：蓝色</li><li>评估脚本 Evaluate Script：黄色</li><li>重新计算样式 Recalculate Style：深紫色</li><li>绘制 Paint：深绿色</li><li>执行微任务 Microtasks：黄色</li><li>Ajax请求 XHR Load：黄色</li><li>函数调用 Function Call：黄色</li><li>触发定时器 Timer Fired：黄色</li></ul><p>还是先大概看下掘金个人主页的火焰图</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8628b108e00743b8bd21cd73f90ec79a~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="总结火焰图的特点" tabindex="-1">总结火焰图的特点 <a class="header-anchor" href="#总结火焰图的特点" aria-label="Permalink to &quot;总结火焰图的特点&quot;">​</a></h3><p>然后用我们小学就学会的<code>看图找规律</code>的技能，找到这个图有什么特点，大致扫一眼，我们就能总结出至少以下几个特点：</p><ul><li>特点一：总的来看两边是空白，中间有三个大火焰</li><li>特点二：两边的两个大火焰正好对应瀑布图的两个空白（这就解释了为什么瀑布图的三个小瀑布之间有空白）</li><li>特点三：有些宏任务特别长，并且背景色是红色的阴影线（而不是灰色）、右上角有一个红色的小三角形</li></ul><p>多花点时间，可能我们还能有更多的发现，不过这几个是最显而易见的。</p><p>为了回答这些问题，我们需要近距离观察下火焰图。</p><h3 id="分析火焰图的含义" tabindex="-1">分析火焰图的含义 <a class="header-anchor" href="#分析火焰图的含义" aria-label="Permalink to &quot;分析火焰图的含义&quot;">​</a></h3><p>既然火焰图代表主线程每个时间点都在干嘛，那么空白自然就意味着主线程没在干活，那么，它在干嘛呢？</p><blockquote><p>它在等待</p></blockquote><p>等待什么呢？</p><blockquote><p>等待服务器返回一些必要的资源和数据</p></blockquote><p>所以</p><blockquote><p>火焰图的空白处都是浏览器在等待服务器返回数据</p></blockquote><h4 id="寻找长任务" tabindex="-1">寻找长任务 <a class="header-anchor" href="#寻找长任务" aria-label="Permalink to &quot;寻找长任务&quot;">​</a></h4><p>在所有主线程执行的任务中，我们尤其需要关注的是那些耗时特别长的长任务（Long task），这些长任务的特点前面已经说了：</p><blockquote><p>背景色是红色的阴影线<br> 右上角有一个红色的小三角形</p></blockquote><p>三个长任务1s钟就找到了</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96b9784630bf40cc8666b482ad3e96c6~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h4 id="分析长任务" tabindex="-1">分析长任务 <a class="header-anchor" href="#分析长任务" aria-label="Permalink to &quot;分析长任务&quot;">​</a></h4><p>接下来是分析长任务，找到耗时长的具体模块/组件/方法。</p><p>我们把最右边最大的那个火焰放大，看看里面到底有些什么秘密。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b57c374140164b0db16ccbc33df04a5d~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>放大之后，我们很快就发现这个耗时591ms的长任务，有90%的时间都花费在了一个叫<code>init</code>的方法上，这个方法一共执行了6次，其中3/4/6耗时尤其长</p><table><thead><tr><th>第n个init方法</th><th>详情</th></tr></thead><tbody><tr><td>3</td><td>耗时：197ms</td></tr><tr><td>4</td><td>耗时：93ms</td></tr><tr><td>6</td><td>耗时：111ms</td></tr></tbody></table><p>这个init方法到底是做什么的呢？</p><p>可能是挂在Vue组件的，会不会是有些组件特别大，里面的逻辑太复杂，这里需要掘金的前端给出答案。</p><p>再看下左边那个第二大的火焰，同样滚动鼠标滚轮把它放大</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/531975d1d5ae4247a2b0a6a77fea01aa~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>我们发现其中有一个forEach循环特别耗时，这个循环好像在计算什么东西，一共花了150ms。</p><p>这个依然需要看下具体的源码才能找到问题的根因。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcce04f337694bbba88f6dc1b1e4ec49~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="通过火焰图发现性能瓶颈的案例" tabindex="-1">通过火焰图发现性能瓶颈的案例 <a class="header-anchor" href="#通过火焰图发现性能瓶颈的案例" aria-label="Permalink to &quot;通过火焰图发现性能瓶颈的案例&quot;">​</a></h3><p>最后给大家分享下我自己之前在XBoard看板项目中，通过火焰图发现一个依赖库的性能问题。</p><p>也是遵循一样的思路：</p><ol><li>找到长任务</li><li>将长任务的火焰图放大</li><li>一层层往下找，直到找到一个耗时长的有名字的方法（现网大部分代码被压缩混淆了，看不出名字，开发环境会更方便定位到存在性能问题的方法）</li><li>在火焰图中点击这个方法，看详情面板中Function后的链接，点击这个链接，直接跳转到相应文件中的指定方法中</li><li>在源码中搜索这个方法名字，找到它</li><li>寻找解决方案</li></ol><p>当时XBoard看板页有一堆长任务，我找了其中的TOP3</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/665fb2258bf9421e8c974da8a2b1fa80~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>然后将第一个长任务放大，很快就有了收获，我发现其中有一个叫<code>drawQrCode</code>的方法耗时比较长，一共花了192ms。</p><p>接着通过查看详情，发现这是一个依赖库的方法，该依赖库定义了一个drawQrCode用来绘制二维码，而这个二维码其实不在看板页面上，而是需要通过鼠标hover到某个按钮上才加载出来。</p><p>所以当时解决的方案就是延迟drawQrCode方法的执行，即：</p><blockquote><p>首页加载时，不执行drawQrCode方法，当鼠标移到相应按钮上时，才执行。</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab9e680a443b4aae970cbccf6edbb601~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="瀑布图和火焰图的关系" tabindex="-1">瀑布图和火焰图的关系 <a class="header-anchor" href="#瀑布图和火焰图的关系" aria-label="Permalink to &quot;瀑布图和火焰图的关系&quot;">​</a></h3><blockquote><p>瀑布图和火焰图是相互补充、相互验证的关系。</p></blockquote><p>瀑布图代表浏览器发起向服务器的请求，然后浏览器根据服务器返回的数据，通过脚本执行相应的逻辑和页面的渲染。</p><p>当瀑布图有请求块时，说明浏览器在向服务器请求数据，如果浏览器必须依赖这些数据来做下一步的页面渲染，那么在服务器返回数据之前，很可能浏览器就没事干，然后火焰图上出现空白，饼图也会出现空闲（Idle）。</p><p>当浏览器拿到服务器返回的数据时，主线程正在处理这些数据，并渲染页面，因此很可能就没法向服务器发请求，这时瀑布图就会出现空白。</p><p>所以</p><blockquote><ol><li>发现瀑布图出现空白，很可能存在长任务，需要找到具体的耗时方法，并进行优化<br></li><li>发现火焰图出现空白，很可能是某些后台接口慢或者存在超大静态资源，需要定位到慢的原因，并想办法优化</li></ol></blockquote><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>本文先给大家简单介绍了如何生成网站的性能分析报告，以及这份报告的大致组成；</p><p>接着跟大家分享我自己在定位业务性能问题时，经常使用的三步法：在瀑布下用火焰烤饼；</p><p>从饼图中我们可以对网站的性能有一个大致的认识，从瀑布图快速地发现慢接口和大资源，而从火焰图中，我们可以细致地洞察到具体哪个模块/哪个组件/哪个方法可能成为性能瓶颈。</p><p>最后给大家推荐 Google 官方的性能评估指南： <a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance" target="_blank" rel="noreferrer">https://developers.google.com/web/tools/chrome-devtools/evaluate-performance</a></p>',188);function b(m,d,f,s,n,h){const e=p("EditInfo");return t(),i("div",null,[r,o(e,{time:"2020年12月12日 23:54",title:"阅读 4315 · 点赞 163 · 评论 22 · 收藏 187"})])}const g=a(c,[["render",b]]);export{k as __pageData,g as default};

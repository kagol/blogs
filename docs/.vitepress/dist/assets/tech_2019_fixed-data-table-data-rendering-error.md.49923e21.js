import{_ as e,B as t,o,c as s,G as l,Q as n}from"./chunks/framework.1fee3549.js";const g=JSON.parse('{"title":"[BUGCASE]FixedDataTable表格数据渲染错误","description":"","frontmatter":{},"headers":[],"relativePath":"tech/2019/fixed-data-table-data-rendering-error.md","filePath":"tech/2019/fixed-data-table-data-rendering-error.md"}'),r={name:"tech/2019/fixed-data-table-data-rendering-error.md"},p=n(`<h1 id="bugcase-fixeddatatable表格数据渲染错误" tabindex="-1">[BUGCASE]FixedDataTable表格数据渲染错误 <a class="header-anchor" href="#bugcase-fixeddatatable表格数据渲染错误" aria-label="Permalink to &quot;[BUGCASE]FixedDataTable表格数据渲染错误&quot;">​</a></h1><h2 id="一、问题描述" tabindex="-1">一、问题描述 <a class="header-anchor" href="#一、问题描述" aria-label="Permalink to &quot;一、问题描述&quot;">​</a></h2><p>广告配置中绑定第三方规格ID表格数据，有一部分展示错乱，具体如下： <img src="https://img2018.cnblogs.com/blog/296720/201901/296720-20190117170658822-362910136.png" alt=""></p><p>表格组件使用 Facebook 的 （<a href="https://github.com/facebookarchive/fixed-data-table" target="_blank" rel="noreferrer">fixed-data-table</a>） 组件</p><h2 id="二、原因分析" tabindex="-1">二、原因分析 <a class="header-anchor" href="#二、原因分析" aria-label="Permalink to &quot;二、原因分析&quot;">​</a></h2><h3 id="_1-检查props" tabindex="-1">1.检查props <a class="header-anchor" href="#_1-检查props" aria-label="Permalink to &quot;1.检查props&quot;">​</a></h3><p>先查看下传入组件中的props是否正确，结果如下图：</p><p><img src="https://img2018.cnblogs.com/blog/296720/201901/296720-20190117170708443-607227924.png" alt=""></p><p>发现传入EditableCell组件的data数据是没有问题的（和后台数据一致），但为什么渲染到页面中就不对呢？</p><h3 id="_2-单元格中的值currentvalue出错" tabindex="-1">2.单元格中的值currentValue出错 <a class="header-anchor" href="#_2-单元格中的值currentvalue出错" aria-label="Permalink to &quot;2.单元格中的值currentValue出错&quot;">​</a></h3><p>这样就直接将错误范围缩小到EditableCell组件，该组件渲染时出错，通过查看该组件源码，发现单元格中的值来自一个内部state: <code>this.state.currentValue</code>，该值在组件初始化时（<code>constructor</code>）设置了一次，在<code>componentWillReceiveProps</code>事件中也设置了一次，具体代码如下：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">constructor(props) {</span></span>
<span class="line"><span style="color:#babed8;">    super(props);</span></span>
<span class="line"><span style="color:#babed8;">    console.log(&#39;props:&#39;, props);</span></span>
<span class="line"><span style="color:#babed8;">    this.state = { editable: false, errorTips: &#39;&#39;, currentValue: this.formatValue(props) };</span></span>
<span class="line"><span style="color:#babed8;">  }</span></span></code></pre></div><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">componentWillReceiveProps(nextProps) {</span></span>
<span class="line"><span style="color:#babed8;">    if(this.props.data !== nextProps.data) {</span></span>
<span class="line"><span style="color:#babed8;">      this.setState({currentValue: this.formatValue(nextProps)});</span></span>
<span class="line"><span style="color:#babed8;">    }</span></span>
<span class="line"><span style="color:#babed8;">  }</span></span></code></pre></div><p>发现currentValue的值都被设置为：<code>this.formatValue(props)</code></p><p>由于其值直接从render中取<code>this.state.currentValue</code>，于是将其打印出来，发现是错的； 再将<code>this.formatValue(this.props)</code>打印出来，值是对的： <img src="https://img2018.cnblogs.com/blog/296720/201901/296720-20190117170957095-2080970133.png" alt=""></p><h3 id="_3-原来是componentwillreceiveprops没执行" tabindex="-1">3.原来是componentWillReceiveProps没执行 <a class="header-anchor" href="#_3-原来是componentwillreceiveprops没执行" aria-label="Permalink to &quot;3.原来是componentWillReceiveProps没执行&quot;">​</a></h3><p>前面已经分析过，<code>this.state.currentValue</code>只在两个地方设置了值，于是在这两个地方分别打印下currentValue的值，结果是：</p><ul><li>constructor执行了21次，打印了前21条数据的currentValue</li><li>componentWillReceiveProps 中设置currentValue的语句没有执行</li></ul><p>当鼠标滚动到第22条数据的位置时，componentWillReceiveProps事件执行了，但是设置currentValue的语句没执行，因为<code> if(this.props.data !== nextProps.data)</code>返回<code>false</code>，试着将判断条件去掉，发现一切正常。</p><h2 id="三、解决方案" tabindex="-1">三、解决方案 <a class="header-anchor" href="#三、解决方案" aria-label="Permalink to &quot;三、解决方案&quot;">​</a></h2><p>将componentWillReceiveProps事件中的<code> if(this.props.data !== nextProps.data)</code>判断条件去掉</p><h2 id="四、深入思考" tabindex="-1">四、深入思考 <a class="header-anchor" href="#四、深入思考" aria-label="Permalink to &quot;四、深入思考&quot;">​</a></h2><p>问题是解决了，可还是总觉得有些地方不是很清楚，比如：</p><ul><li>为什么明明有25条数据，constructor却只执行了21次？</li><li>为什么当鼠标滚动到第22条数据的位置时，componentWillReceiveProps事件会执行？</li></ul><p>于是继续深入研究：</p><h3 id="_1-fixed-data-table数据渲染原理" tabindex="-1">1.fixed-data-table数据渲染原理 <a class="header-anchor" href="#_1-fixed-data-table数据渲染原理" aria-label="Permalink to &quot;1.fixed-data-table数据渲染原理&quot;">​</a></h3><p>通过观察react组件层次结构，发现只有21行数据： <img src="https://img2018.cnblogs.com/blog/296720/201901/296720-20190117170945384-345423080.png" alt=""></p><p>另外4条数据哪去了？于是鼠标往下滚，滚到最后，发现DOM中还是只有21行数据，不过发现一个有趣的现象，最后一个DOM节点指向的并不是最后一条数据，而是第21条数据：</p><p><img src="https://img2018.cnblogs.com/blog/296720/201901/296720-20190117170736605-420575784.png" alt=""></p><p>其他数据去哪儿了？ 通过使用React元素检查器发现，最后4个数据居然跑到最前面去了： <img src="https://img2018.cnblogs.com/blog/296720/201901/296720-20190117170749082-1461094800.png" alt=""></p><p>于是猜想：</p><blockquote><p>fixed-data-table并不是一次性将所有数据渲染到页面上，而是只渲染其中一部分（这里是21条数据），随着鼠标滚动动态渲染。</p></blockquote><p>可是为什么是<code>21</code>行数据（21个DOM节点 FixedDataTableRow）？</p><h3 id="_2-源码研究-dom节点数量的计算" tabindex="-1">2.源码研究：DOM节点数量的计算 <a class="header-anchor" href="#_2-源码研究-dom节点数量的计算" aria-label="Permalink to &quot;2.源码研究：DOM节点数量的计算&quot;">​</a></h3><p>通过研究fixed-data-table的源码<code>FixedDataTableRowBuffer.js</code>发现： <code>21</code>这个数字的计算公式如下：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">var MIN_BUFFER_ROWS = 3;</span></span>
<span class="line"><span style="color:#babed8;">var MAX_BUFFER_ROWS = 6;</span></span>
<span class="line"><span style="color:#babed8;">this._maxVisibleRowCount = Math.ceil(viewportHeight / defaultRowHeight) + 1;//ceil(437/48) = 11</span></span>
<span class="line"><span style="color:#babed8;">    this._bufferRowsCount = clamp(Math.floor(this._maxVisibleRowCount / 2), MIN_BUFFER_ROWS, MAX_BUFFER_ROWS);//clamp方法用于将value限制在[min, max]区间内，这里是[3, 6]</span></span>
<span class="line"><span style="color:#babed8;">//floor(11/2)=5 clamp(5, 3, 6)=5</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">//关键代码</span></span>
<span class="line"><span style="color:#babed8;">var viewportRowsCount = lastViewportRowIndex - firstViewportRowIndex + 1;//可视区域行数</span></span>
<span class="line"><span style="color:#babed8;">var allowedRowsCount = viewportRowsCount + this._bufferRowsCount * 2;//DOM节点数量</span></span>
<span class="line"><span style="color:#babed8;">// allowedRowsCount = 11 + 5*2 = 21</span></span></code></pre></div><h2 id="五、经验沉淀" tabindex="-1">五、经验沉淀 <a class="header-anchor" href="#五、经验沉淀" aria-label="Permalink to &quot;五、经验沉淀&quot;">​</a></h2><ul><li>1.保持谨慎，并及时响应。不忽视小问题，因为小问题有可能会引发更大的问题，对问题及时响应和解决</li><li>2.开发过程中，善于发现隐患，并及时解决</li><li>3.充分自测，自己负责的项目要随时检查是否出故障，最好是能写单元测试，保证质量</li><li>4.多向别人学习，了解不同的思维方式，提高自身解决问题的能力</li><li>5.多总结反思，从问题和错误中学习</li></ul><h2 id="六、致谢-参考资料" tabindex="-1">六、致谢&amp;参考资料 <a class="header-anchor" href="#六、致谢-参考资料" aria-label="Permalink to &quot;六、致谢&amp;参考资料&quot;">​</a></h2><ul><li>感谢在问题排查过程中提供协助的<code>haowei</code> 、<code>afei</code>、<code>yuiffy</code></li><li><a href="https://github.com/facebookarchive/fixed-data-table" target="_blank" rel="noreferrer">https://github.com/facebookarchive/fixed-data-table</a></li><li>fixed-data-table源码</li></ul><h2 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h2><p>一句话总结：</p><blockquote><p>表格单元格中的数据来源于一个内部state currentValue, 该值只在组件首次渲染时设置了一次，并且只设置了前21条数据的值（FixedDataTable<code>动态数据加载机制</code>的原因），而业务中由于一个<code>if逻辑的错误</code>，导致滚动鼠标时，剩余4条本应设置的currentValue没有被设置，从而组件使用了21条数据中的前4条数据的值，导致数据展示错误。</p></blockquote>`,43);function i(c,d,b,h,u,m){const a=t("EditInfo");return o(),s("div",null,[p,l(a,{time:"2019-01-17 17:12",title:"阅读(533) 评论(0) 推荐(1)"})])}const _=e(r,[["render",i]]);export{g as __pageData,_ as default};

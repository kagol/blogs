import{_ as s,B as e,o as n,c as p,G as l,Q as t}from"./chunks/framework.1fee3549.js";const m=JSON.parse('{"title":"如何解决异步接口请求快慢不均导致的数据错误问题？","description":"","frontmatter":{},"headers":[],"relativePath":"tech/2021/asynchronous-interface-request.md","filePath":"tech/2021/asynchronous-interface-request.md"}'),o={name:"tech/2021/asynchronous-interface-request.md"},c=t(`<h1 id="如何解决异步接口请求快慢不均导致的数据错误问题" tabindex="-1">如何解决异步接口请求快慢不均导致的数据错误问题？ <a class="header-anchor" href="#如何解决异步接口请求快慢不均导致的数据错误问题" aria-label="Permalink to &quot;如何解决异步接口请求快慢不均导致的数据错误问题？&quot;">​</a></h1><h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>搜索功能，我想很多业务都会涉及，这个功能的特点是：</p><ul><li>用户可以在输入框中输入一个关键字，然后在一个列表中显示该关键字对应的数据；</li><li>输入框是可以随时修改/删除全部或部分关键字的；</li><li>如果是实时搜索🔍（即输入完关键字马上出结果，不需要额外的操作或过多的等待），接口调用将会非常频繁。</li></ul><p>实时搜索都会面临一个通用的问题，就是：</p><blockquote><p>浏览器请求后台接口都是异步的，如果先发起请求的接口后返回数据，列表/表格中显示的数据就很可能会是错乱的。</p></blockquote><h2 id="问题重现" tabindex="-1">问题重现 <a class="header-anchor" href="#问题重现" aria-label="Permalink to &quot;问题重现&quot;">​</a></h2><p>最近测试提了一个搜索（PS：此处的搜索🔍就是用 DevUI 新推出的 <a href="https://juejin.cn/post/6956612556710477860" target="_blank" rel="noreferrer">CategorySearch</a> 组件实现的）相关的缺陷单，就涉及到了上述问题。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91022a7278ce408ba882bdda2a70d62d~tplv-k3u1fbpfcp-watermark.image" alt="1-1.png"></p><p>这个bug单大致意思是：</p><blockquote><p>搜索的时候，连续快速输入或者删除关键字，搜索结果和搜索关键字不匹配。</p></blockquote><p>从缺陷单的截图来看，本意是要搜索关键字<code>8.4.7迭代】</code>，表格中的实际搜索结果是<code>8.4.7迭代】过</code>关键字的数据。</p><p>缺陷单的截图还非常贴心地贴了两次请求的信息：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd4260a598914a3e924599aaa4688b86~tplv-k3u1fbpfcp-watermark.image" alt="2.png"></p><p>作为一名“有经验的”前端开发，一看就是一个通用的技术问题：</p><ol><li>浏览器从服务器发起的请求都是异步的；</li><li>由于前一次请求服务器返回比较慢，还没等第一次请求返回结果，后一次请求就发起了，并且迅速返回了结果，这时表格肯定显示后一次的结果；</li><li>过了2秒，第一次请求的结果才慢吞吞地返回了，这时表格错误地又显示了第一次请求的结果；</li><li>最终导致了这个bug。</li></ol><p>怎么解决呢？</p><p>在想解决方案之前，得想办法必现这个问题，靠后台接口是不现实的，大部分情况下后台接口都会很快返回结果。</p><p>所以要必现这个问题，得先模拟慢接口。</p><h2 id="模拟慢接口" tabindex="-1">模拟慢接口 <a class="header-anchor" href="#模拟慢接口" aria-label="Permalink to &quot;模拟慢接口&quot;">​</a></h2><p>为了快速搭建一个后台服务，并模拟慢接口，我们选择 <a href="https://koajs.com/" target="_blank" rel="noreferrer">Koa</a> 这个轻量的 Node 框架。</p><h3 id="快速开始" tabindex="-1">快速开始 <a class="header-anchor" href="#快速开始" aria-label="Permalink to &quot;快速开始&quot;">​</a></h3><p>Koa 使用起来非常方便，只需要：</p><ol><li>新建项目文件夹：<code>mkdir koa-server</code></li><li>创建 package.json：<code>npm init -y</code></li><li>安装 Koa：<code>npm i koa</code></li><li>编写服务代码：<code>vi app.js</code></li><li>启动：<code>node app.js</code></li><li>访问：<code>http://localhost:3000/</code></li></ol><h4 id="编写服务代码" tabindex="-1">编写服务代码 <a class="header-anchor" href="#编写服务代码" aria-label="Permalink to &quot;编写服务代码&quot;">​</a></h4><p>使用以下命令创建 app.js 启动文件：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">vi app.js</span></span></code></pre></div><p>在文件中输入以下 3 行代码，即可启动一个 Koa 服务：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">const Koa = require(&#39;koa&#39;); // 引入 Koa</span></span>
<span class="line"><span style="color:#babed8;">const app = new Koa(); // 创建 Koa 实例</span></span>
<span class="line"><span style="color:#babed8;">app.listen(3000); // 监听 3000 端口</span></span></code></pre></div><h4 id="访问" tabindex="-1">访问 <a class="header-anchor" href="#访问" aria-label="Permalink to &quot;访问&quot;">​</a></h4><p>如果没有在3000端口启动任务服务，在浏览器访问：</p><p><code>http://localhost:3000/</code></p><p>会显示以下页面：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95abe405d5fd47f199c70b2c8db3c4f3~tplv-k3u1fbpfcp-watermark.image" alt="3.png"></p><p>启动了我们的 Koa Server 之后，访问：</p><p><code>http://localhost:3000/</code></p><p>会显示：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cd1ccceda0d43018528453bb15fd5fa~tplv-k3u1fbpfcp-watermark.image" alt="4.png"></p><h3 id="get-请求" tabindex="-1">get 请求 <a class="header-anchor" href="#get-请求" aria-label="Permalink to &quot;get 请求&quot;">​</a></h3><p>刚才搭建的只是一个空服务，什么路由都没有，所以显示了<code>Not Found</code>。</p><p>我们可以通过中间件的方式，让我们的 Koa Server 显示点儿东西。</p><p>由于要增加一个根路由，我们先安装路由依赖</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">npm i koa-router</span></span></code></pre></div><p>然后引入 Koa Router</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">const router = require(&#39;koa-router&#39;)();</span></span></code></pre></div><p>接着是编写get接口</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">router.get(&#39;/&#39;, async (ctx, next) =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">  ctx.response.body = &#39;&lt;p&gt;Hello Koa Server!&lt;/p&gt;&#39;;</span></span>
<span class="line"><span style="color:#babed8;">});</span></span></code></pre></div><p>最后别忘了使用路由中间件</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">app.use(router.routes());</span></span></code></pre></div><p>改完代码需要重启 Koa 服务，为了方便重启，我们使用 pm2 这个 Node 进程管理工具来启动/重启 Koa 服务，使用起来也非常简单：</p><ul><li>全局安装 pm2：npm i -g pm2</li><li>启动 Koa Server：pm2 start app.js</li><li>重启 Koa Server：pm2 restart app.js</li></ul><p>重启完 Koa Server，再次访问</p><p><code>http://localhost:3000/</code></p><p>会显示以下内容：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d136ca6d5404485aa59d162aeda33aa5~tplv-k3u1fbpfcp-watermark.image" alt="4-1.png"></p><h3 id="post-请求" tabindex="-1">post 请求 <a class="header-anchor" href="#post-请求" aria-label="Permalink to &quot;post 请求&quot;">​</a></h3><p>有了以上基础，就可以写一个 post 接口，模拟慢接口啦！</p><p>编写 post 接口和 get 接口很类似：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">router.post(&#39;/getList&#39;, async (ctx, next) =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">  ctx.response.body = {</span></span>
<span class="line"><span style="color:#babed8;">    status: 200,</span></span>
<span class="line"><span style="color:#babed8;">    msg: &#39;这是post接口返回的测试数据&#39;,</span></span>
<span class="line"><span style="color:#babed8;">    data: [1, 2, 3]</span></span>
<span class="line"><span style="color:#babed8;">  };</span></span>
<span class="line"><span style="color:#babed8;">});</span></span></code></pre></div><p>这时我们可以使用 Postman 调用下这个 post 接口，如期返回：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49e6fb19f5a040adafc016d544b5e3ef~tplv-k3u1fbpfcp-watermark.image" alt="5.png"></p><h3 id="允许跨域" tabindex="-1">允许跨域 <a class="header-anchor" href="#允许跨域" aria-label="Permalink to &quot;允许跨域&quot;">​</a></h3><p>我们尝试在 NG CLI 项目里调用这个 post 接口：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">this.http.post(&#39;http://localhost:3000/getList&#39;, {</span></span>
<span class="line"><span style="color:#babed8;">  id: 1,</span></span>
<span class="line"><span style="color:#babed8;">}).subscribe(result =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">  console.log(&#39;result:&#39;, result);</span></span>
<span class="line"><span style="color:#babed8;">});</span></span></code></pre></div><p>但是在浏览器里直接调用，却得不到想要的结果：</p><ul><li>result 没有打印出来</li><li>控制台报错</li><li>Network请求也是红色的</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6616b351d65140b594f8baa476a89be0~tplv-k3u1fbpfcp-watermark.image" alt="6.png"></p><p>由于本地启动的项目端口号（4200）和 Koa Server 的（3000）不同，浏览器认为这个接口跨域，因此拦截了。</p><p>NG CLI 项目本地链接：</p><p><code>http://localhost:4200/</code></p><p>Koa Server 链接：</p><p><code>http://localhost:3000/</code></p><p>Koa 有一个中间件可以允许跨域：<code>koa2-cors</code></p><p>这个中间件的使用方式，和路由中间件很类似。</p><p>先安装依赖：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">npm i koa2-cors</span></span></code></pre></div><p>然后引入：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">const cors = require(&#39;koa2-cors&#39;);</span></span></code></pre></div><p>再使用中间件：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">app.use(cors());</span></span></code></pre></div><p>这时我们再去访问：</p><p><code>http://localhost:4200/</code></p><p>就能得到想要的结果啦！</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41af8a8902554f608b234d21d081b348~tplv-k3u1fbpfcp-watermark.image" alt="7.png"></p><h3 id="慢接口" tabindex="-1">慢接口 <a class="header-anchor" href="#慢接口" aria-label="Permalink to &quot;慢接口&quot;">​</a></h3><p>post 接口已经有了，怎么模拟慢接口呢？</p><p>其实就是希望服务器延迟返回结果。</p><p>在 post 接口之前增加延迟的逻辑：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">async function delay(time) {</span></span>
<span class="line"><span style="color:#babed8;">    return new Promise(function(resolve, reject) { </span></span>
<span class="line"><span style="color:#babed8;">      setTimeout(function() {</span></span>
<span class="line"><span style="color:#babed8;">        resolve();</span></span>
<span class="line"><span style="color:#babed8;">      }, time);</span></span>
<span class="line"><span style="color:#babed8;">    });</span></span>
<span class="line"><span style="color:#babed8;">  }</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">  await delay(5000); // 延迟 5s 返回结果</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">  ctx.response.body = { ... };</span></span></code></pre></div><p>再次访问 getList 接口，发现前面接口会一直<code>pending</code>，5s 多才真正返回结果。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad9f89986c754b1a81aa9b2549698c3f~tplv-k3u1fbpfcp-watermark.image" alt="8.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0023a013aa37415eab1a7874c66bc7cc~tplv-k3u1fbpfcp-watermark.image" alt="9.png"></p><h2 id="取消慢接口请求" tabindex="-1">取消慢接口请求 <a class="header-anchor" href="#取消慢接口请求" aria-label="Permalink to &quot;取消慢接口请求&quot;">​</a></h2><p>能模拟慢接口，就能轻易地必现测试提的问题啦！</p><blockquote><p>先必现这个问题，然后尝试修复这个问题，最后看下这个问题还出不出现，不出现说明我们的方案能解决这个bug，问题还有说明我们得想别的办法。</p></blockquote><p>这是修复bug正确的打开方式。</p><p>最直观的方案就是再发起第二次请求之后，如果第一次请求未返回，那就直接取消这次请求，使用第二次请求的返回结果。</p><p>怎么取消一次http请求呢？</p><p>Angular 的异步事件机制是基于 RxJS 的，取消一个正在执行的 http 请求非常方便。</p><p>前面已经看到 Angular 使用 HttpClient 服务来发起 http 请求，并调用subscribe 方法来订阅后台的返回结果：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">this.http.post(&#39;http://localhost:3000/getList&#39;, {</span></span>
<span class="line"><span style="color:#babed8;">  id: 1,</span></span>
<span class="line"><span style="color:#babed8;">}).subscribe(result =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">  console.log(&#39;result:&#39;, result);</span></span>
<span class="line"><span style="color:#babed8;">});</span></span></code></pre></div><p>要取消 http 请求，我们需要先把这个订阅存到组件一个变量里：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">private getListSubscription: Subscription;</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">this.getListSubscription = this.http.post(&#39;http://localhost:3000/getList&#39;, {</span></span>
<span class="line"><span style="color:#babed8;">  id: 1,</span></span>
<span class="line"><span style="color:#babed8;">}).subscribe(result =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">  console.log(&#39;result:&#39;, result);</span></span>
<span class="line"><span style="color:#babed8;">});</span></span></code></pre></div><p>然后在重新发起 http 请求之前，取消上一次请求的订阅即可。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">this.getListSubscription?.unsubscribe(); // 重新发起 http 请求之前，取消上一次请求的订阅</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">this.getListSubscription = this.http.post(...);</span></span></code></pre></div><h2 id="其他-http-库如何取消请求" tabindex="-1">其他 http 库如何取消请求 <a class="header-anchor" href="#其他-http-库如何取消请求" aria-label="Permalink to &quot;其他 http 库如何取消请求&quot;">​</a></h2><p>至此这个缺陷算是解决了，其实这是一个通用的问题，不管是在什么业务，使用什么框架，都会遇到异步接口慢导致的数据错乱问题。</p><p>那么，如果使用 fetch 这种浏览器原生的 http 请求接口或者 <a href="https://axios-http.com/" target="_blank" rel="noreferrer">axios</a> 这种业界广泛使用的 http 库，怎么取消正在进行的 http 请求呢？</p><h3 id="fetch" tabindex="-1">fetch <a class="header-anchor" href="#fetch" aria-label="Permalink to &quot;fetch&quot;">​</a></h3><p>先来看下 fetch，fetch 是浏览器原生提供的 AJAX 接口，使用起来也非常方便。</p><p>使用 fetch 发起一个 post 请求：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">fetch(&#39;http://localhost:3000/getList&#39;, {</span></span>
<span class="line"><span style="color:#babed8;">   method: &#39;POST&#39;,</span></span>
<span class="line"><span style="color:#babed8;">　　headers: {</span></span>
<span class="line"><span style="color:#babed8;">　　　　&#39;Content-Type&#39;: &#39;application/json;charset=utf-8&#39;</span></span>
<span class="line"><span style="color:#babed8;">　　},</span></span>
<span class="line"><span style="color:#babed8;">　　body: JSON.stringify({</span></span>
<span class="line"><span style="color:#babed8;">    id: 1</span></span>
<span class="line"><span style="color:#babed8;">　　})</span></span>
<span class="line"><span style="color:#babed8;">}).then(result =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">  console.log(&#39;result&#39;, result);</span></span>
<span class="line"><span style="color:#babed8;">});</span></span></code></pre></div><p>可以使用 <code>AbortController</code> 来实现请求取消：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">this.controller?.abort(); // 重新发起 http 请求之前，取消上一次请求</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">const controller = new AbortController(); //  创建 AbortController 实例</span></span>
<span class="line"><span style="color:#babed8;">const signal = controller.signal;</span></span>
<span class="line"><span style="color:#babed8;">this.controller = controller;</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">fetch(&#39;http://localhost:3000/getList&#39;, {</span></span>
<span class="line"><span style="color:#babed8;">   method: &#39;POST&#39;,</span></span>
<span class="line"><span style="color:#babed8;">　　headers: {</span></span>
<span class="line"><span style="color:#babed8;">　　　　&#39;Content-Type&#39;: &#39;application/json;charset=utf-8&#39;</span></span>
<span class="line"><span style="color:#babed8;">　　},</span></span>
<span class="line"><span style="color:#babed8;">　　body: JSON.stringify({</span></span>
<span class="line"><span style="color:#babed8;">    id: 1</span></span>
<span class="line"><span style="color:#babed8;">　　}),</span></span>
<span class="line"><span style="color:#babed8;">  signal, // 信号参数，用来控制 http 请求的执行</span></span>
<span class="line"><span style="color:#babed8;">}).then(result =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">  console.log(&#39;result&#39;, result);</span></span>
<span class="line"><span style="color:#babed8;">});</span></span></code></pre></div><h3 id="axios" tabindex="-1">axios <a class="header-anchor" href="#axios" aria-label="Permalink to &quot;axios&quot;">​</a></h3><p>再来看看 axios，先看下如何使用 axios 发起 post 请求。</p><p>先安装：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">npm i axios</span></span></code></pre></div><p>再引入：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">import axios from &#39;axios&#39;;</span></span></code></pre></div><p>发起 post 请求：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">axios.post(&#39;http://localhost:3000/getList&#39;, {</span></span>
<span class="line"><span style="color:#babed8;">  headers: {</span></span>
<span class="line"><span style="color:#babed8;">    &#39;Content-Type&#39;: &#39;application/json;charset=utf-8&#39;</span></span>
<span class="line"><span style="color:#babed8;">  },</span></span>
<span class="line"><span style="color:#babed8;">  data: {</span></span>
<span class="line"><span style="color:#babed8;">    id: 1,</span></span>
<span class="line"><span style="color:#babed8;">  },</span></span>
<span class="line"><span style="color:#babed8;">})</span></span>
<span class="line"><span style="color:#babed8;">.then(result =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">  console.log(&#39;result:&#39;, result);</span></span>
<span class="line"><span style="color:#babed8;">});</span></span></code></pre></div><p>axios 发起的请求可以通过 cancelToken 来取消。</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#babed8;">this.source?.cancel(&#39;The request is canceled!&#39;);</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">this.source = axios.CancelToken.source(); // 初始化 source 对象</span></span>
<span class="line"><span style="color:#babed8;"></span></span>
<span class="line"><span style="color:#babed8;">axios.post(&#39;http://localhost:3000/getList&#39;, {</span></span>
<span class="line"><span style="color:#babed8;">  headers: {</span></span>
<span class="line"><span style="color:#babed8;">    &#39;Content-Type&#39;: &#39;application/json;charset=utf-8&#39;</span></span>
<span class="line"><span style="color:#babed8;">  },</span></span>
<span class="line"><span style="color:#babed8;">  data: {</span></span>
<span class="line"><span style="color:#babed8;">    id: 1,</span></span>
<span class="line"><span style="color:#babed8;">  },</span></span>
<span class="line"><span style="color:#babed8;">}, { // 注意是第三个参数</span></span>
<span class="line"><span style="color:#babed8;">  cancelToken: this.source.token, // 这里声明的 cancelToken 其实相当于是一个标记或者信号</span></span>
<span class="line"><span style="color:#babed8;">})</span></span>
<span class="line"><span style="color:#babed8;">.then(result =&gt; {</span></span>
<span class="line"><span style="color:#babed8;">  console.log(&#39;result:&#39;, result);</span></span>
<span class="line"><span style="color:#babed8;">});</span></span></code></pre></div><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>本文通过实际项目中遇到的问题，总结缺陷分析和解决的通用方法，并对异步接口请求导致的数据错误问题进行了深入的解析。</p>`,126);function i(r,b,d,h,u,y){const a=e("EditInfo");return n(),p("div",null,[c,l(a,{time:"2021年05月08日 07:56",title:"阅读 4297 ·  点赞 58 ·  评论 36 ·  收藏 50"})])}const f=s(o,[["render",i]]);export{m as __pageData,f as default};
